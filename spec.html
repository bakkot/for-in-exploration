<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: For-in enumeration order
stage: 1
contributors: Kevin Gibbons
</pre>

<emu-intro id="sec-intro">
  <h1>Introduction</h1>
  <p>The order of `for (a in b) ...` is specified in EnumerateObjectProperties, but only loosely. This proposal aims to begin fixing that.</p>
</emu-intro>

<emu-clause id="sec-enumerate-object-properties" aoid="EnumerateObjectProperties">
  <h1>EnumerateObjectProperties ( _O_ )</h1>
  <p>When the abstract operation EnumerateObjectProperties is called with argument _O_, the following steps are taken:</p>
  <emu-alg>
    1. Assert: Type(_O_) is Object.
    1. Return an Iterator object (<emu-xref href="#sec-iterator-interface"></emu-xref>) whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.
  </emu-alg>
  <p>The iterator's `throw` and `return` methods are *null* and are never invoked. The iterator's `next` method processes object properties to determine whether the property key should be returned as an iterator value. Returned property keys do not include keys that are Symbols. Properties of the target object may be deleted during enumeration. A property that is deleted before it is processed by the iterator's `next` method is ignored. If new properties are added to the target object during enumeration, the newly added properties are not guaranteed to be processed in the active enumeration. A property name will be returned by the iterator's `next` method at most once in any enumeration.</p>
  <p>Enumerating the properties of the target object includes enumerating properties of its prototype, and the prototype of the prototype, and so on, recursively; but a property of a prototype is not processed if it has the same name as a property that has already been processed by the iterator's `next` method. The values of [[Enumerable]] attributes are not considered when determining if a property of a prototype object has already been processed. The enumerable property names of prototype objects must be obtained by invoking EnumerateObjectProperties passing the prototype object as the argument. EnumerateObjectProperties must obtain the own property keys of the target object by calling its [[OwnPropertyKeys]] internal method. Property attributes of the target object must be obtained by calling its [[GetOwnProperty]] internal method.</p>
  <p><ins>In addition, if neither _O_ nor any object in its prototype chain is an exotic object, then the iterator must behave identically to that in the NOTE below until either _O_ or an object in its prototype chain has its `[[SetPrototypeOf]]`, `[[DefineOwnProperty]]`, or `[[Delete]]` internal method invoked.</ins></p>

  <emu-note><ins>
    Engines are not expected to check the cosntrainst in the previous paragraph. Instead, they can choose an implementation which will behave identically to the algorithm below as long as the above constraints are met.
  </ins></emu-note>

  <emu-note type=editor>TODO write the implementation below in spec text.</emu-note>
  </emu-note>
  <emu-note>
    <p>The following is an informative definition of an ECMAScript generator function that conforms to these rules:</p>
    <pre><code class="javascript">
      function* EnumerateObjectProperties(obj) {
        const visited = new Set();
        for (const key of Reflect.ownKeys(obj)) {
          if (typeof key === "symbol") continue;
          const desc = Reflect.getOwnPropertyDescriptor(obj, key);
          if (desc) {
            visited.add(key);
            if (desc.enumerable) yield key;
          }
        }
        const proto = Reflect.getPrototypeOf(obj);
        if (proto === null) return;
        for (const protoKey of EnumerateObjectProperties(proto)) {
          if (!visited.has(protoKey)) yield protoKey;
        }
      }
    </code></pre>
  </emu-note>
</emu-clause>
</emu-clause>
</emu-clause>
